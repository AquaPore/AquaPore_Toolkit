# =============================================================
#		module: kunsatModel jesus
# =============================================================
module Œ∏œà_2_KsœàModel
	import ..cst, ..distribution, ..wrc
	import QuadGK
	import SpecialFunctions: erfc, erfcinv
	
	export KSŒ®MODEL_START

	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#		FUNCTION : KSŒ®MODEL_START
	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		function KSŒ®MODEL_START(hydro, ipClass, iZ, ksmodelœÑ, option, Œ®‚ÇÅ; Flag_IsTopsoil=false, Flag_RockFragment=false, IsTopsoil=[], RockFragment=[])

			if Flag_RockFragment
				RockFragment‚ÇÅ = RockFragment[iZ]
			else
				RockFragment‚ÇÅ = 0.0
			end #@isdefined RockFragment

			# if Flag_IsTopsoil
			# 	IsTopsoil‚ÇÅ = Int64(IsTopsoil[iZ])
			# else
			# 	IsTopsoil‚ÇÅ = 1	# Default value				
			# end  # if: @isdefined IsTopsoil

			return KsŒ®model = TORTUOSITYMODELS(hydro, option, ipClass, iZ, ksmodelœÑ, Œ®‚ÇÅ; RockFragment=RockFragment‚ÇÅ, Smap_ImpermClass=[], KsImpClass_Dict=[])
		end  # function: KS_MODEL
	#..................................................................


	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#		FUNCTION : KsŒ®MODEL
	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		function KsŒ®MODEL(hydro, iZ::Int64, option‚Çò, T1, T1Mac, T2, T2Mac, T3, T3Mac, Œ∏r, Œ∏s, Œ∏sMacMat, œÉ, œÉMac, Œ®‚ÇÅ::Float64, Œ®m, Œ®mMac)

			# Se ===
				Se = wrc.kg.Œ®_2_SeDual(option‚Çò, Œ®‚ÇÅ, iZ, hydro)

			# Matrix ====	
				Ks_Mat = T1 * cst.KunsatModel * œÄ * ((Œ∏sMacMat - Œ∏r) * ((cst.Y / Œ®m) ^ T2) * exp(((T2 * œÉ) ^ 2.0) / 2.0)) ^ T3

				Kunsat_Mat = Ks_Mat * ‚àöSe * (0.5 * erfc(((log(Œ®‚ÇÅ / Œ®m)) / œÉ + œÉ) / ‚àö2.0)) ^ 2.0

			# Macropore ===
				Ks_Mac = T1Mac * cst.KunsatModel * œÄ * ((Œ∏s - Œ∏sMacMat) * ((cst.Y / Œ®mMac) ^ T2Mac) * exp(((T2Mac * œÉMac) ^ 2.0) / 2.0)) ^ T3Mac

				Kunsat_Mac = Ks_Mac * ‚àöSe * (0.5 * erfc(((log(Œ®‚ÇÅ / Œ®mMac)) / œÉMac + œÉMac) / ‚àö2.0)) ^ 2.0
		return K_Œ® = Kunsat_Mat + Kunsat_Mac
		end  # function: KsŒ®MODEL
	# ------------------------------------------------------------------



	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#		FUNCTION : KsŒ®MODEL_OLD
	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		"""Pollacco, J.A.P., Webb, T., McNeill, S., Hu, W., Carrick, S., Hewitt, A., Lilburne, L., 2017. Saturated hydraulic conductivity model computed from bimodal water retention curves for a range of New Zealand soils. Hydrol. Earth Syst. Sci. 21, 2725‚Äì2737. https://doi.org/10.5194/hess-21-2725-2017"""
		function KsŒ®MODEL_OLD(hydro, iZ::Int64, option‚Çò, T1, T1Mac, T2, T2Mac, T3, T3Mac, Œ∏r, Œ∏s, Œ∏sMacMat, œÉ, œÉMac, Œ®‚ÇÅ::Float64, Œ®m, Œ®mMac)

			# Ks Matrix ====	
				Ks_Mat = T1 * cst.KunsatModel * œÄ * ((Œ∏sMacMat - Œ∏r) * ((cst.Y / Œ®m) ^ T2) * exp(((T2 * œÉ) ^ 2.0) / 2.0)) ^ T3

			# Ks Macropore ===
				Ks_Mac = T1Mac * cst.KunsatModel * œÄ * ((Œ∏s - Œ∏sMacMat) * ((cst.Y / Œ®mMac) ^ T2Mac) * exp(((T2Mac * œÉMac) ^ 2.0) / 2.0)) ^ T3Mac
			
			Ks = Ks_Mat + Ks_Mac 
				
			# K(Œ®)
				Se = wrc.kg.Œ®_2_SeDual(option‚Çò, Œ®‚ÇÅ, iZ, hydro)	

				KsMat = Ks * (Œ∏sMacMat - Œ∏r) / (Œ∏s - Œ∏r)
				Kr_Mat =  KsMat * ‚àöSe * (0.5 * erfc(((log(Œ®‚ÇÅ / Œ®m)) / œÉ + œÉ) / ‚àö2.0)) ^ 2.0

				KsMac = Ks * (Œ∏s - Œ∏sMacMat) / (Œ∏s - Œ∏r)
				Kr_Mac = KsMac * ‚àöSe * (0.5 * erfc(((log(Œ®‚ÇÅ / Œ®mMac)) / œÉMac + œÉMac) / ‚àö2.0)) ^ 2.0

		return K_Œ® =  Ks * (Kr_Mat + Kr_Mac) 
		end  # function: KsŒ®MODEL_OLD
	# ------------------------------------------------------------------


	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#		FUNCTION : TORTUOSITYMODELS
	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		function TORTUOSITYMODELS(hydro, option, ipClass, iZ::Int64,ksmodelœÑ, Œ®‚ÇÅ; RockFragment=0.0, Œ∏s=hydro.Œ∏s[iZ], Œ∏r=hydro.Œ∏r[iZ], Œ®m=hydro.Œ®m[iZ], œÉ=hydro.œÉ[iZ], Œ∏sMacMat=hydro.Œ∏sMacMat[iZ], Œ®mMac=hydro.Œ®mMac[iZ], œÉMac=hydro.œÉMac[iZ], œÑ‚ÇÅ‚Çê=ksmodelœÑ.œÑ‚ÇÅ‚Çê[ipClass],œÑ‚ÇÅ·µ¶=ksmodelœÑ.œÑ‚ÇÅ·µ¶[ipClass], œÑ‚ÇÇ‚Çê=ksmodelœÑ.œÑ‚ÇÇ‚Çê[ipClass], œÑ‚ÇÇ·µ¶=ksmodelœÑ.œÑ‚ÇÇ·µ¶[ipClass], œÑ‚ÇÉ‚Çê=ksmodelœÑ.œÑ‚ÇÉ‚Çê[ipClass], œÑ‚ÇÉ·µ¶=ksmodelœÑ.œÑ‚ÇÉ·µ¶[ipClass], œÑ‚ÇÅ‚ÇêMac=ksmodelœÑ.œÑ‚ÇÅ‚ÇêMac[ipClass],œÑ‚ÇÅ·µ¶Mac=ksmodelœÑ.œÑ‚ÇÅ·µ¶Mac[ipClass], œÑ‚ÇÇ‚ÇêMac=ksmodelœÑ.œÑ‚ÇÇ‚ÇêMac[ipClass], œÑ‚ÇÇ·µ¶Mac=ksmodelœÑ.œÑ‚ÇÇ·µ¶Mac[ipClass], œÑ‚ÇÉ‚ÇêMac=ksmodelœÑ.œÑ‚ÇÉ‚ÇêMac[ipClass], œÑ‚ÇÉ·µ¶Mac=ksmodelœÑ.œÑ‚ÇÉ·µ¶Mac, RockFragment_Treshold=0.4, Smap_ImpermClass=[], KsImpClass_Dict=[] )

			# Determine when Ks increases for increasing RockFragment	
				if RockFragment > RockFragment_Treshold
					Œ∏r, Œ∏s, Œ∏sMacMat = ROCKCORRECTION(RockFragment, RockFragment_Treshold, Œ∏r, Œ∏s, Œ∏sMacMat)
				end

				# MODEL 1 ====			
				if option.ksModel.K‚ÇõModel‚ç∞=="KsŒ®model_1" # ===
					# Transformation matrix
					# Transformation matrix
					T1 = 10.0 ^ (œÑ‚ÇÅ‚Çê / (œÑ‚ÇÅ‚Çê - 1.0))
					T2_Min = 1.0; T2_Max = 3.0
					T2 = (T2_Min - T2_Max) * œÑ‚ÇÇ‚Çê + T2_Max
					T3 = œÑ‚ÇÉ‚Çê

				# Transformation macro
					T1Mac = 10.0 ^ (œÑ‚ÇÅ‚ÇêMac / (œÑ‚ÇÅ‚ÇêMac - 1.0))
					T2Mac = (T2_Min - T2_Max) * œÑ‚ÇÇ‚ÇêMac + T2_Max
					T3Mac = œÑ‚ÇÉ‚ÇêMac				
					return KsŒ®MODEL(hydro, iZ, option.hydro, T1, T1Mac, T2, T2Mac, T3, T3Mac, Œ∏r, Œ∏s, Œ∏sMacMat, œÉ, œÉMac, Œ®‚ÇÅ, Œ®m, Œ®mMac)

				# MODEL 2 ====			
				elseif option.ksModel.K‚ÇõModel‚ç∞=="KsŒ®model_2" # ===
					# Transformation matrix

					X1 = 1.8
					Y1 = œÑ‚ÇÅ‚Çê 
					X2 = 3.7
					Y2 = œÑ‚ÇÅ·µ¶ * œÑ‚ÇÅ‚Çê
					A  = (Y2 - Y1) / (X2 - X1)
					B  = Y1 - X1 * A

					T1_ùî£ = max(min(A * œÉ + B, œÑ‚ÇÅ‚Çê), 0.0)


					# X1 = 1.8
					# Y1 = œÑ‚ÇÅ‚Çê 
					# X2 = 3.7
					# Y2 = œÑ‚ÇÅ·µ¶ * œÑ‚ÇÅ‚Çê
					# A  = (Y2 - Y1) / (X2 - X1)
					# B  = Y1 - X1 * A


					T1 = 10.0 ^ (T1_ùî£ / (T1_ùî£ - 1.0))
					T2_Min = 1.0; T2_Max = 4.0
					T2 = (T2_Min - T2_Max) * œÑ‚ÇÇ‚Çê + T2_Max
					T3 = œÑ‚ÇÉ‚Çê

				# Transformation macro
					T1Mac = 10.0 ^ (œÑ‚ÇÅ‚ÇêMac / (œÑ‚ÇÅ‚ÇêMac - 1.0))
					T2Mac = (T2_Min - T2_Max) * œÑ‚ÇÇ‚ÇêMac + T2_Max
					T3Mac = œÑ‚ÇÉ‚ÇêMac							
			 
			return KsŒ®MODEL(hydro, iZ, option.hydro, T1, T1Mac, T2, T2Mac, T3, T3Mac, Œ∏r, Œ∏s, Œ∏sMacMat, œÉ, œÉMac, Œ®‚ÇÅ, Œ®m, Œ®mMac)

				# MODEL 3 ====			
				elseif option.ksModel.K‚ÇõModel‚ç∞=="KsŒ®model_3" # ===
					# Transformation matrix
					# Function to correct for clay
					X1 = œÑ‚ÇÅ·µ¶
					Y1 = 1.0
					X2 = 1.0
					Y2 = œÑ‚ÇÇ·µ¶	
					A  = (Y2 - Y1) / (X2 - X1)
					B  = Y1 - X1 * A
					œÉŒ∑ = œÉ_2_œÉŒ∑(hydro, iZ, œÉ)
					# Func_T1 = max( (A * (œÉŒ∑ ^ 2) + B), 0.0)
					# Func_T1 = œÑMODEL_œÉ(hydro, iZ,  œÑ‚ÇÅ·µ¶, œÑ‚ÇÇ·µ¶, œÉ; Inverse=true, œÑ‚ÇÑ=1.0)

					Func_T1 = 1
					T1 = 10.0 ^ ( Func_T1 * (œÑ‚ÇÅ‚Çê / (œÑ‚ÇÅ‚Çê - 1.0)))
					# Func_T1 = 0.1698 * œÉ + 0.3449						
					# T1 = 10.0 ^ ( Func_T1 / (Func_T1 - 1.0))

					# T1 = 10.0 ^ (Func_T1a / (Func_T1a - 1.0))
					T2_Min = 1.0; T2_Max = 3.0
					T2 = (T2_Min - T2_Max) * œÑ‚ÇÇ‚Çê + T2_Max
					T3 = œÑ‚ÇÉ‚Çê

				# Transformation macro
					T1Mac = 10.0 ^ (œÑ‚ÇÅ‚ÇêMac / (œÑ‚ÇÅ‚ÇêMac - 1.0))
					T2Mac = (T2_Min - T2_Max)  * œÑ‚ÇÇ‚ÇêMac + T2_Max
					T3Mac = œÑ‚ÇÉ‚ÇêMac								
					return KsŒ®MODEL_OLD(hydro, iZ, option.hydro, T1, T1Mac, T2, T2Mac, T3, T3Mac, Œ∏r, Œ∏s, Œ∏sMacMat, œÉ, œÉMac, Œ®‚ÇÅ, Œ®m, Œ®mMac)
				

						# MODEL 2 ====			
				elseif option.ksModel.K‚ÇõModel‚ç∞=="KsŒ®model_4" # ===

	
					# Func_T1 = œÑMODEL_œÉ(hydro, iZ,  œÑ‚ÇÅ·µ¶, œÑ‚ÇÇ·µ¶, œÉ; Inverse=true, œÑ‚ÇÑ=1.0)

					# Func_T1 = 1
					# T1 = 10.0 ^ ( Func_T1 * (œÑ‚ÇÅ‚Çê / (œÑ‚ÇÅ‚Çê - 1.0)))
					# Func_T1 = min(max(0.3231 * œÉ - 0.0276, 0.0), 0.99)

					# if œÉ > 2.5
					# 	# Func_T1 = 1.0 - max(min(œÑ‚ÇÅ‚Çê * log(Œ®m) * œÉ + œÑ‚ÇÅ·µ¶, 1.0), 0.001)
						# Func_T1 = 1.0 - max(min(œÑ‚ÇÅ‚Çê * log(Œ®m), 1.0), 0.001)
						œÉŒ∑ = œÉ_2_œÉŒ∑(hydro, iZ, œÉ)
						Func_T1 =  œÑMODEL_œÉ(hydro, iZ, œÑ‚ÇÅ‚Çê, œÑ‚ÇÅ·µ¶, œÉ; Inverse=false, œÑ‚ÇÑ=2.0)
					# else
					# 	Func_T1 =  œÑ‚ÇÅ·µ¶
					# end			
								
					T1 = 10.0 ^ ( Func_T1 / (Func_T1 - 1.0))

					# T1 = 10.0 ^ (Func_T1a / (Func_T1a - 1.0))
					T2_Min = 1.0; T2_Max = 3.0
					T2 = (T2_Min - T2_Max) * œÑ‚ÇÇ‚Çê + T2_Max

					# Function to correct for clay
						X1 = 0
						Y1 = 1.0
						X2 = 1.0
						Y2 = 1.0	
						A  = (Y2 - Y1) / (X2 - X1)
						B  = Y1 - X1 * A

					T3 = œÑMODEL_œÉ(hydro, iZ, œÑ‚ÇÉ‚Çê, œÑ‚ÇÉ·µ¶, œÉ; Inverse=false, œÑ‚ÇÑ=2.0)

				# Transformation macro
					T1Mac =  (10.0 ^ (œÑ‚ÇÅ‚ÇêMac / (œÑ‚ÇÅ‚ÇêMac - 1.0)))
					T2Mac = (T2_Min - T2_Max)  * œÑ‚ÇÇ‚ÇêMac + T2_Max
					T3Mac = œÑ‚ÇÉ‚ÇêMac								
					return KsŒ®MODEL(hydro, iZ, option.hydro, T1, T1Mac, T2, T2Mac, T3, T3Mac, Œ∏r, Œ∏s, Œ∏sMacMat, œÉ, œÉMac, Œ®‚ÇÅ, Œ®m, Œ®mMac)
				
				else
					error("option.ksModel.K‚ÇõModel‚ç∞ = $(option.ksModel.K‚ÇõModel‚ç∞) is not yet implemented try <KsModel_Traditional>; <KsModel_TœÉ>; <KsModel_New>; <KsModel_NewSimplified> ")
					
				end  # if: Model=="Model?"
		end  # function: TORTUOSITYMODELS 


	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#		FUNCTION : ROCKCORRECTION
	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		function ROCKCORRECTION(RockFragment, RockFragment_Treshold, Œ∏r, Œ∏s, Œ∏sMacMat)
				RockFragment2 = max(2.0 * RockFragment_Treshold - RockFragment, 0.0)

				Œ∏s = (Œ∏s / (1.0 - RockFragment)) * (1.0 - RockFragment2)
				
				Œ∏sMacMat = (Œ∏sMacMat / (1.0 - RockFragment)) * (1.0 - RockFragment2)

				Œ∏r = (Œ∏r / (1.0 - RockFragment)) * (1.0 - RockFragment2)		
		return Œ∏r, Œ∏s, Œ∏sMacMat
		end  # function: ROCKCORRECTION
	# ------------------------------------------------------------------

	# =====================================================================================================================
	# =====================================================================================================================


	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#		FUNCTION :  œÑMODEL_œÉSilt
	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		function œÑMODEL_œÉSilt_œÉ(hydro, iZ, P‚Çò·µ¢‚Çô, P‚Çò‚Çê‚Çì, œÉ; Amplitude=0.5, œÉSilt_Œ∑=0.538, PœÉ=3, Distribution‚ç∞="Normal", Normalise=true, Invert=false)
			œÉŒ∑ = œÑMODEL_œÉ(hydro, iZ, P‚Çò‚Çê‚Çì, P‚Çò·µ¢‚Çô, œÉ)

			œÑœÉ_Dist = œÑMODEL_œÉSilt(hydro, iZ, P‚Çò‚Çê‚Çì, P‚Çò·µ¢‚Çô, œÉŒ∑; œÉSilt_Œ∑=œÉSilt_Œ∑, PœÉ=PœÉ, Distribution‚ç∞="Normal", Normalise=Normalise, Invert=Invert)

			œÑœÉ = œÑMODEL_œÉ(hydro, iZ, P‚Çò‚Çê‚Çì, P‚Çò·µ¢‚Çô, œÉ)

		return œÑ = min(œÑœÉ + Amplitude * (œÑœÉ_Dist / (œÉSilt_Œ∑ + 1.0)) , 1.0) * (P‚Çò‚Çê‚Çì - P‚Çò·µ¢‚Çô) + P‚Çò·µ¢‚Çô
		end
	#..................................................................


	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#		FUNCTION :  œÑMODEL_œÉSilt
	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		function œÑMODEL_œÉSilt(hydro, iZ, P‚Çò·µ¢‚Çô, P‚Çò‚Çê‚Çì,  œÉ; œÉSilt_Œ∑=0.538, PœÉ=3.0, Distribution‚ç∞="Normal", Normalise=true, Invert=false)

			œÉŒ∑ = œÑMODEL_œÉ(hydro, iZ, P‚Çò‚Çê‚Çì, P‚Çò·µ¢‚Çô, œÉ)

			if  Distribution‚ç∞== "Normal"
				œÉ_Dist = œÉSilt_Œ∑ / PœÉ

			elseif  Distribution‚ç∞== "LogNormal"
				œÉ_Dist = log(œÉSilt_Œ∑) / PœÉ

			else
				error("*** œÑMODEL_œÉSilt: $Distribution‚ç∞ not implemented try <Normal> or  <LogNormal>  ***")
			end

			œÑœÉ_Dist = distribution.DISTRIBUTION(œÉŒ∑, œÉSilt_Œ∑, œÉ_Dist; Distribution‚ç∞=Distribution‚ç∞, Normalise=Normalise, Invert=Invert)[1]
		return œÑ = œÑœÉ_Dist  * (P‚Çò‚Çê‚Çì - P‚Çò·µ¢‚Çô) + P‚Çò·µ¢‚Çô
		end
	#..................................................................


	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#		FUNCTION : œÑMODEL_œÉ
	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		function œÑMODEL_œÉ(hydro, iZ,  P‚Çò·µ¢‚Çô, P‚Çò‚Çê‚Çì, œÉ; Inverse=false, œÑ‚ÇÑ=0.5)
			œÉŒ∑ = œÉ_2_œÉŒ∑(hydro, iZ, œÉ)
			if Inverse
				return œÑ = (1.0 - œÉŒ∑) ^ œÑ‚ÇÑ  * (P‚Çò‚Çê‚Çì - P‚Çò·µ¢‚Çô) + P‚Çò·µ¢‚Çô
			else
				return œÑ = œÉŒ∑ ^ œÑ‚ÇÑ  * (P‚Çò‚Çê‚Çì - P‚Çò·µ¢‚Çô) + P‚Çò·µ¢‚Çô
			end	
		end
	#..................................................................


	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#		FUNCTION :œÑMODEL_œÉ2
	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		function œÑMODEL_œÉ2(hydro, iZ,  P‚Çò·µ¢‚Çô, P‚Çò‚Çê‚Çì, œÉ; œÑ‚ÇÑ=0.5, œÉboundWater = 0.5)
			œÉŒ∑ = œÉ_2_œÉŒ∑(hydro, iZ, œÉ)

		return œÑ = (P‚Çò‚Çê‚Çì - P‚Çò·µ¢‚Çô) * min((œÉŒ∑ / œÉboundWater) ^ œÑ‚ÇÑ, 1.0) + P‚Çò·µ¢‚Çô
		end
	#..................................................................


	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#		FUNCTION : œÑMODEL_Œ∏sŒ∏r
	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		function œÑMODEL_Œ∏sŒ∏r(hydro, iZ,  P‚Çò·µ¢‚Çô, P‚Çò‚Çê‚Çì, Œ∏s, Œ∏r, Œ∏sMacMat)
			Œ∏Œ∑ = (Œ∏s - Œ∏r)
		return œÑ = (1.0 - Œ∏Œ∑)  * (P‚Çò‚Çê‚Çì - P‚Çò·µ¢‚Çô) + P‚Çò·µ¢‚Çô
		end
	#..................................................................


	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	#		FUNCTION : œÉ_2_œÉŒ∑
	# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		function œÉ_2_œÉŒ∑(hydro, iZ, œÉ)
			return œÉŒ∑ = (œÉ - hydro.œÉ_Min[iZ]) / (hydro.œÉ_Max[iZ] - hydro.œÉ_Min[iZ])
		end  # function: œÉ_2_œÉŒ∑
	# ------------------------------------------------------------------


end  # module Œ∏œà_2_KsœàModel
# ............................................................